GAS LISTING init.s 			page 1


   1              	#--------------------------------------------------------------------------
   2              	# init.s:  Initialize simple kernel with a GDT and an IDT
   3              	#
   4              	# Mark P. Jones, April 2006, 2016
   5              	
   6              	#--------------------------------------------------------------------------
   7              	# General definitions:
   8              	#--------------------------------------------------------------------------
   9              	
  10              		.set	RESERVED, 0	# Used to mark a reserved field
  11              	
  12              	#--------------------------------------------------------------------------
  13              	# Initial stack:
  14              	#--------------------------------------------------------------------------
  15              	
  16              		.data
  17 0000 00000000 		.space	4096		# Kernel stack
  17      00000000 
  17      00000000 
  17      00000000 
  17      00000000 
  18              	stack:
  19              	
  20              	#--------------------------------------------------------------------------
  21              	# Entry point:
  22              	#--------------------------------------------------------------------------
  23              	
  24              		.text
  25              		.globl	entry
  26 0000 FA       	entry:	cli			# Turn off interrupts
  27 0001 8D250010 		leal	stack, %esp	# Set up initial kernel stack
  27      0000
  28              	
  29 0007 E80D0000 		call	initGDT		# Set up global segment table
  29      00
  30 000c E85D0100 		call	initIDT		# Set up interrupt descriptor table
  30      00
  31 0011 E8FCFFFF 		call	kernel		# Enter main kernel
  31      FF
  32              	
  33 0016 F4       	1:	hlt			# Catch all, in case kernel returns
  34 0017 EBFD     		jmp	1b
  35              	
  36              	#--------------------------------------------------------------------------
  37              	# Task-state Segment (TSS):
  38              	#
  39              	# We provide only a single Task-State Segment (TSS); we want to support
  40              	# lighter-weight task switching than is provided by the hardware.  But
  41              	# we still need a tss to store the kernel stack pointer and segment.
  42              	#--------------------------------------------------------------------------
  43              	
  44              		.data
  45 1000 00000000 	tss:	.short	0, RESERVED		# previous task link
  46 1004 00000000 	esp0:	.long	0			# esp0
  47 1008 00000000 		.short	KERN_DS, RESERVED	# ss0
  48 100c 00000000 		.long	0			# esp1
  49 1010 00000000 		.short	0, RESERVED		# ss1
GAS LISTING init.s 			page 2


  50 1014 00000000 		.long	0			# esp2
  51 1018 00000000 		.short	0, RESERVED		# ss2
  52 101c 00000000 		.long	0, 0, 0			# cr3 (pdbr), eip, eflags
  52      00000000 
  52      00000000 
  53 1028 00000000 		.long	0, 0, 0, 0, 0		# eax, ecx, edx, ebx, esp
  53      00000000 
  53      00000000 
  53      00000000 
  53      00000000 
  54 103c 00000000 		.long	0, 0, 0			# ebp, esi, edi
  54      00000000 
  54      00000000 
  55 1048 00000000 		.short	0, RESERVED		# es
  56 104c 00000000 		.short	0, RESERVED		# cs
  57 1050 00000000 		.short	0, RESERVED		# ss
  58 1054 00000000 		.short	0, RESERVED		# ds
  59 1058 00000000 		.short	0, RESERVED		# fs
  60 105c 00000000 		.short	0, RESERVED		# gs
  61 1060 00000000 		.short	0, RESERVED		# ldt segment selector
  62 1064 0000     		.short	0			# T bit
  63              		#
  64              		# For now, we set the I/O bitmap offset to a value beyond the limit
  65              		# of the tss; following Intel documentation, this means that there
  66              		# is no I/O permissions bitmap and all I/O instructions will
  67              		# generate exceptions when CPL > IOPL.
  68              		#
  69 1066 E803     		.short	1000			# I/O bit map base address
  70              		.set	tss_len, .-tss
  71              	
  72              	#--------------------------------------------------------------------------
  73              	# Initialize gdt:
  74              	#
  75              	# There are eight entries in our GDT:
  76              	#   0  null		; null entry required by Intel architecture
  77              	#   1  reserved
  78              	#   2  reserved
  79              	#   3  tss
  80              	#   4  kernel code	; kernel segments
  81              	#   5  kernel data
  82              	#   6  user code	; user segments
  83              	#   7  user data
  84              	# For the purposes of caching, we will start the GDT at a 128 byte aligned
  85              	# address; older processors have 32 byte cache lines while newer ones have
  86              	# 128 bytes per cache line.  The inclusion of a reserved entry (1) in the
  87              	# GDT ensures that the four {kernel,user}{code,data} segments all fit in a
  88              	# single cache line, even on older machines.  (I got this idea after reading
  89              	# the O'Reilly book on the Linux Kernel, but I have no idea if it makes
  90              	# a significant difference in practice ...)
  91              	#--------------------------------------------------------------------------
  92              	
  93              		.set	GDT_ENTRIES, 8
  94              		.set	GDT_SIZE, 8*GDT_ENTRIES	# 8 bytes for each descriptor
  95              	
  96              		.data
  97 1068 00000000 		.align  128
  97      00000000 
GAS LISTING init.s 			page 3


  97      00000000 
  97      00000000 
  97      00000000 
  98              	#	.globl	gdt			# retain for debugging
  99 1080 00000000 	gdt:	.space	GDT_SIZE, 0
  99      00000000 
  99      00000000 
  99      00000000 
  99      00000000 
 100              	
 101              		.align	8
 102 10c0 3F00     	gdtptr:	.short	GDT_SIZE-1
 103 10c2 80100000 		.long	gdt
 104              	
 105              		.set	GDT_DATA,  0x13		# descriptor type for data segment
 106              		.set	GDT_CODE,  0x1b		# descriptor type for code segment
 107              		.set	GDT_TSS32, 0x09		# descriptor type for 32-bit tss
 108              	
 109              		.text
 110              		.macro	gdtset name, slot, base, limit, gran, dpl, type
 111              		#
 112              		# This macro calculates a GDT segment descriptor from a specified
 113              		# base address (32 bits), limit (20 bits), granularity (1 bit),
 114              		# dpl (2 bits) and type (5 bits).  The descriptor is a 64 bit
 115              		# quantity that is calculated in the register pair edx:eax and
 116              		# also stored in the specified slot of the gdt.  The ebx and ecx
 117              		# registers are also overwritten in the process.
 118              		#
 119              		# The format of a segment descriptor requires us to chop up the
 120              		# base and limit values with bit twiddling manipulations that
 121              		# cannot, in general, be performed at assembly time.  (The
 122              		# base address, in particular, may be a relocatable symbol.)
 123              		# The following macro makes it easier for us to perform the
 124              		# necessary calculations for each segment at runtime.
 125              		#
 126              		# gran = 0 => limit is last valid byte offset in segment
 127              		# gran = 1 => limit is last valid page offset in segment
 128              		#
 129              		# type = 0x13 (GDT_DATA)  => data segment
 130              		# type = 0x1b (GDT_CODE)  => code segment
 131              		# type = 0x09 (GDT_TSS32) => 32 bit tss system descriptor
 132              		#
 133              		# The following comments use # for concatenation of bitdata
 134              		#
 135              		.set	\name, (\slot<<3)|\dpl
 136              		.globl	\name
 137              		movl	$\base, %eax	# eax = bhi # bmd # blo
 138              		movl	$\limit, %ebx	# ebx = ~ # lhi # llo
 139              	
 140              		mov	%eax, %edx	# edx = base
 141              		shl	$16, %eax	# eax = blo # 0
 142              		mov	%bx, %ax	# eax = blo # llo
 143              		movl	%eax, gdt+(8*\slot)
 144              	
 145              		shr	$16, %edx	# edx = 0 # bhi # bmd
 146              		mov	%edx, %ecx	# ecx = 0 # bhi # bmd
 147              		andl	$0xff, %ecx	# ecx = 0 # 0   # bmd
GAS LISTING init.s 			page 4


 148              		xorl	%ecx, %edx	# edx = 0 # bhi # bmd
 149              		shl	$16,%edx	# edx = bhi # 0
 150              		orl	%ecx, %edx	# edx = bhi # 0 # bmd
 151              		andl	$0xf0000, %ebx	# ebx = 0 # lhi # 0
 152              		orl	%ebx, %edx	# edx = bhi # 0 # lhi # 0 # bmd
 153              		#
 154              		# The constant 0x4080 used below is a combination of:
 155              		#  0x4000     sets the D/B bit to indicate a 32-bit segment
 156              		#  0x0080     sets the P bit to indicate that descriptor is present
 157              		# (\gran<<15) puts the granularity bit into place
 158              		# (\dpl<<5)   puts the protection level into place
 159              		# \type       is the 5 bit type, including the S bit as its MSB
 160              		#
 161              		orl	$(((\gran<<15) | 0x4080 | (\dpl<<5) | \type)<<8), %edx
 162              		movl	%edx, gdt + (4 + 8*\slot)
 163              		.endm
 164              	
 165              	initGDT:# Kernel code segment:
 166              		gdtset	name=KERN_CS, slot=4, dpl=0, type=GDT_CODE, base=0, limit=0xffffff, gran=1
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  .set KERN_CS,(4<<3)|0
 166              	>  .globl KERN_CS
 166 0019 B8000000 	>  movl $0,%eax
 166      00
 166 001e BBFFFFFF 	>  movl $0xffffff,%ebx
 166      00
 166              	> 
 166 0023 89C2     	>  mov %eax,%edx
 166 0025 C1E010   	>  shl $16,%eax
 166 0028 6689D8   	>  mov %bx,%ax
 166 002b A3A01000 	>  movl %eax,gdt+(8*4)
 166      00
 166              	> 
 166 0030 C1EA10   	>  shr $16,%edx
GAS LISTING init.s 			page 5


 166 0033 89D1     	>  mov %edx,%ecx
 166 0035 81E1FF00 	>  andl $0xff,%ecx
 166      0000
 166 003b 31CA     	>  xorl %ecx,%edx
 166 003d C1E210   	>  shl $16,%edx
 166 0040 09CA     	>  orl %ecx,%edx
 166 0042 81E30000 	>  andl $0xf0000,%ebx
 166      0F00
 166 0048 09DA     	>  orl %ebx,%edx
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166              	>  
 166 004a 81CA009B 	>  orl $(((1<<15)|0x4080|(0<<5)|GDT_CODE)<<8),%edx
 166      C000
 166 0050 8915A410 	>  movl %edx,gdt+(4+8*4)
 166      0000
 167              	
 168              		# Kernel data segment:
 169              		gdtset	name=KERN_DS, slot=5, dpl=0, type=GDT_DATA, base=0, limit=0xffffff, gran=1
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  .set KERN_DS,(5<<3)|0
 169              	>  .globl KERN_DS
 169 0056 B8000000 	>  movl $0,%eax
 169      00
 169 005b BBFFFFFF 	>  movl $0xffffff,%ebx
 169      00
 169              	> 
 169 0060 89C2     	>  mov %eax,%edx
 169 0062 C1E010   	>  shl $16,%eax
GAS LISTING init.s 			page 6


 169 0065 6689D8   	>  mov %bx,%ax
 169 0068 A3A81000 	>  movl %eax,gdt+(8*5)
 169      00
 169              	> 
 169 006d C1EA10   	>  shr $16,%edx
 169 0070 89D1     	>  mov %edx,%ecx
 169 0072 81E1FF00 	>  andl $0xff,%ecx
 169      0000
 169 0078 31CA     	>  xorl %ecx,%edx
 169 007a C1E210   	>  shl $16,%edx
 169 007d 09CA     	>  orl %ecx,%edx
 169 007f 81E30000 	>  andl $0xf0000,%ebx
 169      0F00
 169 0085 09DA     	>  orl %ebx,%edx
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169              	>  
 169 0087 81CA0093 	>  orl $(((1<<15)|0x4080|(0<<5)|GDT_DATA)<<8),%edx
 169      C000
 169 008d 8915AC10 	>  movl %edx,gdt+(4+8*5)
 169      0000
 170              	
 171              		# User code segment
 172              		gdtset	name=USER_CS, slot=6, dpl=3, type=GDT_CODE, base=0, limit=0xffffff, gran=1
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  .set USER_CS,(6<<3)|3
 172              	>  .globl USER_CS
 172 0093 B8000000 	>  movl $0,%eax
 172      00
GAS LISTING init.s 			page 7


 172 0098 BBFFFFFF 	>  movl $0xffffff,%ebx
 172      00
 172              	> 
 172 009d 89C2     	>  mov %eax,%edx
 172 009f C1E010   	>  shl $16,%eax
 172 00a2 6689D8   	>  mov %bx,%ax
 172 00a5 A3B01000 	>  movl %eax,gdt+(8*6)
 172      00
 172              	> 
 172 00aa C1EA10   	>  shr $16,%edx
 172 00ad 89D1     	>  mov %edx,%ecx
 172 00af 81E1FF00 	>  andl $0xff,%ecx
 172      0000
 172 00b5 31CA     	>  xorl %ecx,%edx
 172 00b7 C1E210   	>  shl $16,%edx
 172 00ba 09CA     	>  orl %ecx,%edx
 172 00bc 81E30000 	>  andl $0xf0000,%ebx
 172      0F00
 172 00c2 09DA     	>  orl %ebx,%edx
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172              	>  
 172 00c4 81CA00FB 	>  orl $(((1<<15)|0x4080|(3<<5)|GDT_CODE)<<8),%edx
 172      C000
 172 00ca 8915B410 	>  movl %edx,gdt+(4+8*6)
 172      0000
 173              	
 174              		# User data segment
 175              		gdtset	name=USER_DS, slot=7, dpl=3, type=GDT_DATA, base=0, limit=0xffffff, gran=1
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175              	>  
GAS LISTING init.s 			page 8


 175              	>  
 175              	>  .set USER_DS,(7<<3)|3
 175              	>  .globl USER_DS
 175 00d0 B8000000 	>  movl $0,%eax
 175      00
 175 00d5 BBFFFFFF 	>  movl $0xffffff,%ebx
 175      00
 175              	> 
 175 00da 89C2     	>  mov %eax,%edx
 175 00dc C1E010   	>  shl $16,%eax
 175 00df 6689D8   	>  mov %bx,%ax
 175 00e2 A3B81000 	>  movl %eax,gdt+(8*7)
 175      00
 175              	> 
 175 00e7 C1EA10   	>  shr $16,%edx
 175 00ea 89D1     	>  mov %edx,%ecx
 175 00ec 81E1FF00 	>  andl $0xff,%ecx
 175      0000
 175 00f2 31CA     	>  xorl %ecx,%edx
 175 00f4 C1E210   	>  shl $16,%edx
 175 00f7 09CA     	>  orl %ecx,%edx
 175 00f9 81E30000 	>  andl $0xf0000,%ebx
 175      0F00
 175 00ff 09DA     	>  orl %ebx,%edx
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175              	>  
 175 0101 81CA00F3 	>  orl $(((1<<15)|0x4080|(3<<5)|GDT_DATA)<<8),%edx
 175      C000
 175 0107 8915BC10 	>  movl %edx,gdt+(4+8*7)
 175      0000
 176              	
 177              		# TSS
 178              		gdtset	name=TSS, slot=3, dpl=0, type=GDT_TSS32, base=tss, limit=tss_len-1, gran=0
 178              	>  
 178              	>  
 178              	>  
 178              	>  
 178              	>  
 178              	>  
 178              	>  
 178              	>  
 178              	>  
 178              	>  
 178              	>  
 178              	>  
 178              	>  
 178              	>  
 178              	>  
 178              	>  
 178              	>  
 178              	>  
GAS LISTING init.s 			page 9


 178              	>  
 178              	>  
 178              	>  
 178              	>  
 178              	>  
 178              	>  
 178              	>  .set TSS,(3<<3)|0
 178              	>  .globl TSS
 178 010d B8001000 	>  movl $tss,%eax
 178      00
 178 0112 BB670000 	>  movl $tss_len-1,%ebx
 178      00
 178              	> 
 178 0117 89C2     	>  mov %eax,%edx
 178 0119 C1E010   	>  shl $16,%eax
 178 011c 6689D8   	>  mov %bx,%ax
 178 011f A3981000 	>  movl %eax,gdt+(8*3)
 178      00
 178              	> 
 178 0124 C1EA10   	>  shr $16,%edx
 178 0127 89D1     	>  mov %edx,%ecx
 178 0129 81E1FF00 	>  andl $0xff,%ecx
 178      0000
 178 012f 31CA     	>  xorl %ecx,%edx
 178 0131 C1E210   	>  shl $16,%edx
 178 0134 09CA     	>  orl %ecx,%edx
 178 0136 81E30000 	>  andl $0xf0000,%ebx
 178      0F00
 178 013c 09DA     	>  orl %ebx,%edx
 178              	>  
 178              	>  
 178              	>  
 178              	>  
 178              	>  
 178              	>  
 178              	>  
 178              	>  
 178 013e 81CA0089 	>  orl $(((0<<15)|0x4080|(0<<5)|GDT_TSS32)<<8),%edx
 178      4000
 178 0144 89159C10 	>  movl %edx,gdt+(4+8*3)
 178      0000
 179              	
 180 014a 0F0115C0 		lgdt	gdtptr
 180      100000
 181 0151 EA580100 		ljmp	$KERN_CS, $1f		# load code segment
 181      002000
 182              	1:
 183 0158 66B82800 		mov	$KERN_DS, %ax		# load data segments
 184 015c 8ED8     		mov 	%ax, %ds
 185 015e 8EC0     		mov 	%ax, %es
 186 0160 8ED0     		mov 	%ax, %ss
 187 0162 8EE8     		mov	%ax, %gs
 188 0164 8EE0     		mov 	%ax, %fs
 189 0166 66B81800 		mov	$TSS, %ax		# load task register
 190 016a 0F00D8   		ltr	%ax
 191 016d C3       		ret
 192              	
GAS LISTING init.s 			page 10


 193              	#--------------------------------------------------------------------------
 194              	# IDT:
 195              	#--------------------------------------------------------------------------
 196              	
 197              		.set	IDT_ENTRIES, 256	# Allow for all possible interrupts
 198              		.set	IDT_SIZE, 8*IDT_ENTRIES	# Eight bytes for each idt descriptor
 199              		.set	IDT_INTR, 0x000		# Type for interrupt gate
 200              		.set	IDT_TRAP, 0x100		# Type for trap gate
 201              	
 202              		.data
 203 10c6 0000     		.align	8
 204 10c8 FF07     	idtptr:	.short	IDT_SIZE-1
 205 10ca D0100000 		.long	idt
 206 10ce 0000     		.align  8
 207 10d0 00000000 	idt:	.space	IDT_SIZE, 0		# zero initial entries
 207      00000000 
 207      00000000 
 207      00000000 
 207      00000000 
 208              	
 209              		.text
 210              		.macro	idtcalc	handler, slot, dpl=0, type=IDT_INTR, seg=KERN_CS
 211              		#
 212              		# This macro calculates an IDT segment descriptor from a specified
 213              		# segment (16 bits), handler address (32 bits), dpl (2 bits) and
 214              		# type (5 bits).  The descriptor is a 64 bit # quantity that is
 215              		# calculated in the register pair edx:eax and then stored in the
 216              		# specified slot of the IDT.
 217              		#
 218              		# type = 0x000 (IDT_INTR)  => interrupt gate
 219              		# type = 0x100 (IDT_TRAP)  => trap gate
 220              		#
 221              		# The following comments use # for concatenation of bitdata
 222              		#
 223              		mov	$\seg, %ax		# eax =   ? # seg
 224              		shl	$16, %eax		# eax = seg #   0
 225              		movl	$\handler, %edx		# edx = hhi # hlo
 226              		mov	%dx, %ax		# eax = seg # hlo
 227              		mov	$(0x8e00 | (\dpl<<13) | \type), %dx
 228              		movl	%eax, idt + (    8*\slot)
 229              		movl	%edx, idt + (4 + 8*\slot)
 230              		.endm
 231              	
 232              	initIDT:# Add descriptors for exception & interrupt handlers:
 233              		.irp	num, 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,16,17,18,19
 233              	>  idtcalc exc0,slot=0
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
GAS LISTING init.s 			page 11


 233              	>>  
 233 016e 66B82000 	>>  mov $KERN_CS,%ax
 233 0172 C1E010   	>>  shl $16,%eax
 233 0175 BAD00300 	>>  movl $exc0,%edx
 233      00
 233 017a 6689D0   	>>  mov %dx,%ax
 233 017d 66BA008E 	>>  mov $(0x8e00|(0<<13)|IDT_INTR),%dx
 233 0181 A3D01000 	>>  movl %eax,idt+( 8*0)
 233      00
 233 0186 8915D410 	>>  movl %edx,idt+(4+8*0)
 233      0000
 233              	> 
 233              	>  idtcalc exc1,slot=1
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233 018c 66B82000 	>>  mov $KERN_CS,%ax
 233 0190 C1E010   	>>  shl $16,%eax
 233 0193 BAF00300 	>>  movl $exc1,%edx
 233      00
 233 0198 6689D0   	>>  mov %dx,%ax
 233 019b 66BA008E 	>>  mov $(0x8e00|(0<<13)|IDT_INTR),%dx
 233 019f A3D81000 	>>  movl %eax,idt+( 8*1)
 233      00
 233 01a4 8915DC10 	>>  movl %edx,idt+(4+8*1)
 233      0000
 233              	> 
 233              	>  idtcalc exc2,slot=2
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233 01aa 66B82000 	>>  mov $KERN_CS,%ax
 233 01ae C1E010   	>>  shl $16,%eax
 233 01b1 BA100400 	>>  movl $exc2,%edx
 233      00
 233 01b6 6689D0   	>>  mov %dx,%ax
 233 01b9 66BA008E 	>>  mov $(0x8e00|(0<<13)|IDT_INTR),%dx
 233 01bd A3E01000 	>>  movl %eax,idt+( 8*2)
 233      00
GAS LISTING init.s 			page 12


 233 01c2 8915E410 	>>  movl %edx,idt+(4+8*2)
 233      0000
 233              	> 
 233              	>  idtcalc exc3,slot=3
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233 01c8 66B82000 	>>  mov $KERN_CS,%ax
 233 01cc C1E010   	>>  shl $16,%eax
 233 01cf BA300400 	>>  movl $exc3,%edx
 233      00
 233 01d4 6689D0   	>>  mov %dx,%ax
 233 01d7 66BA008E 	>>  mov $(0x8e00|(0<<13)|IDT_INTR),%dx
 233 01db A3E81000 	>>  movl %eax,idt+( 8*3)
 233      00
 233 01e0 8915EC10 	>>  movl %edx,idt+(4+8*3)
 233      0000
 233              	> 
 233              	>  idtcalc exc4,slot=4
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233 01e6 66B82000 	>>  mov $KERN_CS,%ax
 233 01ea C1E010   	>>  shl $16,%eax
 233 01ed BA500400 	>>  movl $exc4,%edx
 233      00
 233 01f2 6689D0   	>>  mov %dx,%ax
 233 01f5 66BA008E 	>>  mov $(0x8e00|(0<<13)|IDT_INTR),%dx
 233 01f9 A3F01000 	>>  movl %eax,idt+( 8*4)
 233      00
 233 01fe 8915F410 	>>  movl %edx,idt+(4+8*4)
 233      0000
 233              	> 
 233              	>  idtcalc exc5,slot=5
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
GAS LISTING init.s 			page 13


 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233 0204 66B82000 	>>  mov $KERN_CS,%ax
 233 0208 C1E010   	>>  shl $16,%eax
 233 020b BA700400 	>>  movl $exc5,%edx
 233      00
 233 0210 6689D0   	>>  mov %dx,%ax
 233 0213 66BA008E 	>>  mov $(0x8e00|(0<<13)|IDT_INTR),%dx
 233 0217 A3F81000 	>>  movl %eax,idt+( 8*5)
 233      00
 233 021c 8915FC10 	>>  movl %edx,idt+(4+8*5)
 233      0000
 233              	> 
 233              	>  idtcalc exc6,slot=6
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233 0222 66B82000 	>>  mov $KERN_CS,%ax
 233 0226 C1E010   	>>  shl $16,%eax
 233 0229 BA900400 	>>  movl $exc6,%edx
 233      00
 233 022e 6689D0   	>>  mov %dx,%ax
 233 0231 66BA008E 	>>  mov $(0x8e00|(0<<13)|IDT_INTR),%dx
 233 0235 A3001100 	>>  movl %eax,idt+( 8*6)
 233      00
 233 023a 89150411 	>>  movl %edx,idt+(4+8*6)
 233      0000
 233              	> 
 233              	>  idtcalc exc7,slot=7
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233 0240 66B82000 	>>  mov $KERN_CS,%ax
 233 0244 C1E010   	>>  shl $16,%eax
GAS LISTING init.s 			page 14


 233 0247 BAB00400 	>>  movl $exc7,%edx
 233      00
 233 024c 6689D0   	>>  mov %dx,%ax
 233 024f 66BA008E 	>>  mov $(0x8e00|(0<<13)|IDT_INTR),%dx
 233 0253 A3081100 	>>  movl %eax,idt+( 8*7)
 233      00
 233 0258 89150C11 	>>  movl %edx,idt+(4+8*7)
 233      0000
 233              	> 
 233              	>  idtcalc exc8,slot=8
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233 025e 66B82000 	>>  mov $KERN_CS,%ax
 233 0262 C1E010   	>>  shl $16,%eax
 233 0265 BAD00400 	>>  movl $exc8,%edx
 233      00
 233 026a 6689D0   	>>  mov %dx,%ax
 233 026d 66BA008E 	>>  mov $(0x8e00|(0<<13)|IDT_INTR),%dx
 233 0271 A3101100 	>>  movl %eax,idt+( 8*8)
 233      00
 233 0276 89151411 	>>  movl %edx,idt+(4+8*8)
 233      0000
 233              	> 
 233              	>  idtcalc exc9,slot=9
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233 027c 66B82000 	>>  mov $KERN_CS,%ax
 233 0280 C1E010   	>>  shl $16,%eax
 233 0283 BAF00400 	>>  movl $exc9,%edx
 233      00
 233 0288 6689D0   	>>  mov %dx,%ax
 233 028b 66BA008E 	>>  mov $(0x8e00|(0<<13)|IDT_INTR),%dx
 233 028f A3181100 	>>  movl %eax,idt+( 8*9)
 233      00
 233 0294 89151C11 	>>  movl %edx,idt+(4+8*9)
 233      0000
 233              	> 
GAS LISTING init.s 			page 15


 233              	>  idtcalc exc10,slot=10
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233 029a 66B82000 	>>  mov $KERN_CS,%ax
 233 029e C1E010   	>>  shl $16,%eax
 233 02a1 BA100500 	>>  movl $exc10,%edx
 233      00
 233 02a6 6689D0   	>>  mov %dx,%ax
 233 02a9 66BA008E 	>>  mov $(0x8e00|(0<<13)|IDT_INTR),%dx
 233 02ad A3201100 	>>  movl %eax,idt+( 8*10)
 233      00
 233 02b2 89152411 	>>  movl %edx,idt+(4+8*10)
 233      0000
 233              	> 
 233              	>  idtcalc exc11,slot=11
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233 02b8 66B82000 	>>  mov $KERN_CS,%ax
 233 02bc C1E010   	>>  shl $16,%eax
 233 02bf BA300500 	>>  movl $exc11,%edx
 233      00
 233 02c4 6689D0   	>>  mov %dx,%ax
 233 02c7 66BA008E 	>>  mov $(0x8e00|(0<<13)|IDT_INTR),%dx
 233 02cb A3281100 	>>  movl %eax,idt+( 8*11)
 233      00
 233 02d0 89152C11 	>>  movl %edx,idt+(4+8*11)
 233      0000
 233              	> 
 233              	>  idtcalc exc12,slot=12
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
GAS LISTING init.s 			page 16


 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233 02d6 66B82000 	>>  mov $KERN_CS,%ax
 233 02da C1E010   	>>  shl $16,%eax
 233 02dd BA500500 	>>  movl $exc12,%edx
 233      00
 233 02e2 6689D0   	>>  mov %dx,%ax
 233 02e5 66BA008E 	>>  mov $(0x8e00|(0<<13)|IDT_INTR),%dx
 233 02e9 A3301100 	>>  movl %eax,idt+( 8*12)
 233      00
 233 02ee 89153411 	>>  movl %edx,idt+(4+8*12)
 233      0000
 233              	> 
 233              	>  idtcalc exc13,slot=13
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233 02f4 66B82000 	>>  mov $KERN_CS,%ax
 233 02f8 C1E010   	>>  shl $16,%eax
 233 02fb BA700500 	>>  movl $exc13,%edx
 233      00
 233 0300 6689D0   	>>  mov %dx,%ax
 233 0303 66BA008E 	>>  mov $(0x8e00|(0<<13)|IDT_INTR),%dx
 233 0307 A3381100 	>>  movl %eax,idt+( 8*13)
 233      00
 233 030c 89153C11 	>>  movl %edx,idt+(4+8*13)
 233      0000
 233              	> 
 233              	>  idtcalc exc14,slot=14
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233 0312 66B82000 	>>  mov $KERN_CS,%ax
 233 0316 C1E010   	>>  shl $16,%eax
 233 0319 BA900500 	>>  movl $exc14,%edx
 233      00
 233 031e 6689D0   	>>  mov %dx,%ax
GAS LISTING init.s 			page 17


 233 0321 66BA008E 	>>  mov $(0x8e00|(0<<13)|IDT_INTR),%dx
 233 0325 A3401100 	>>  movl %eax,idt+( 8*14)
 233      00
 233 032a 89154411 	>>  movl %edx,idt+(4+8*14)
 233      0000
 233              	> 
 233              	>  idtcalc exc16,slot=16
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233 0330 66B82000 	>>  mov $KERN_CS,%ax
 233 0334 C1E010   	>>  shl $16,%eax
 233 0337 BAB00500 	>>  movl $exc16,%edx
 233      00
 233 033c 6689D0   	>>  mov %dx,%ax
 233 033f 66BA008E 	>>  mov $(0x8e00|(0<<13)|IDT_INTR),%dx
 233 0343 A3501100 	>>  movl %eax,idt+( 8*16)
 233      00
 233 0348 89155411 	>>  movl %edx,idt+(4+8*16)
 233      0000
 233              	> 
 233              	>  idtcalc exc17,slot=17
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233 034e 66B82000 	>>  mov $KERN_CS,%ax
 233 0352 C1E010   	>>  shl $16,%eax
 233 0355 BAD00500 	>>  movl $exc17,%edx
 233      00
 233 035a 6689D0   	>>  mov %dx,%ax
 233 035d 66BA008E 	>>  mov $(0x8e00|(0<<13)|IDT_INTR),%dx
 233 0361 A3581100 	>>  movl %eax,idt+( 8*17)
 233      00
 233 0366 89155C11 	>>  movl %edx,idt+(4+8*17)
 233      0000
 233              	> 
 233              	>  idtcalc exc18,slot=18
 233              	>>  
 233              	>>  
GAS LISTING init.s 			page 18


 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233 036c 66B82000 	>>  mov $KERN_CS,%ax
 233 0370 C1E010   	>>  shl $16,%eax
 233 0373 BAF00500 	>>  movl $exc18,%edx
 233      00
 233 0378 6689D0   	>>  mov %dx,%ax
 233 037b 66BA008E 	>>  mov $(0x8e00|(0<<13)|IDT_INTR),%dx
 233 037f A3601100 	>>  movl %eax,idt+( 8*18)
 233      00
 233 0384 89156411 	>>  movl %edx,idt+(4+8*18)
 233      0000
 233              	> 
 233              	>  idtcalc exc19,slot=19
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233              	>>  
 233 038a 66B82000 	>>  mov $KERN_CS,%ax
 233 038e C1E010   	>>  shl $16,%eax
 233 0391 BA100600 	>>  movl $exc19,%edx
 233      00
 233 0396 6689D0   	>>  mov %dx,%ax
 233 0399 66BA008E 	>>  mov $(0x8e00|(0<<13)|IDT_INTR),%dx
 233 039d A3681100 	>>  movl %eax,idt+( 8*19)
 233      00
 233 03a2 89156C11 	>>  movl %edx,idt+(4+8*19)
 233      0000
 234              		idtcalc	exc\num, slot=\num
 235              		.endr
 236              	
 237              		# Add descriptors for hardware irqs:
 238              	
 239              		# Add descriptors for system calls:
 240              	        # These are the only idt entries that we will allow to be called from
 241              	        # user mode without generating a general protection fault, so they
 242              	        # will be tagged with dpl=3
 243              		idtcalc	handler=syscall, slot=0x80, dpl=3
 243              	>  
 243              	>  
 243              	>  
GAS LISTING init.s 			page 19


 243              	>  
 243              	>  
 243              	>  
 243              	>  
 243              	>  
 243              	>  
 243              	>  
 243              	>  
 243              	>  
 243 03a8 66B82000 	>  mov $KERN_CS,%ax
 243 03ac C1E010   	>  shl $16,%eax
 243 03af BA620600 	>  movl $syscall,%edx
 243      00
 243 03b4 6689D0   	>  mov %dx,%ax
 243 03b7 66BA00EE 	>  mov $(0x8e00|(3<<13)|IDT_INTR),%dx
 243 03bb A3D01400 	>  movl %eax,idt+( 8*0x80)
 243      00
 243 03c0 8915D414 	>  movl %edx,idt+(4+8*0x80)
 243      0000
 244              	
 245              		# Install the new IDT:
 246 03c6 0F011DC8 		lidt	idtptr
 246      100000
 247 03cd C3       		ret
 248              	
 249              		#---------------------------------------------------------------------
 250              		# Exception handlers:
 251              	
 252              		.text
 253              		.macro	handler num, func, errorcode=0
 254              		.align	16
 255              	exc\num:
 256              		.if	\errorcode==0
 257              		subl	$4, %esp	# fake an error code if necessary
 258              		.endif
 259              		push	%gs		# Save segments
 260              		push	%fs
 261              		push	%es
 262              		push	%ds
 263              		pusha			# Save registers
 264              		push	%esp		# push pointer to frame for handler
 265              		movl	$\num, %eax
 266              		call	\func
 267              		addl	$4, %esp
 268              		popl	%es
 269              		popl	%ds
 270              		popa
 271              		addl	$4, %esp	# remove error code
 272              		iret
 273              		.endm
 274              	
 275              		# Protected-mode exceptions and interrupts:
 276              		#
 277              		handler	num=0,  func=nohandler			# divide error
 277 03ce 6690     	>  .align 16
 277              	> exc0:
 277              	>  .if 0==0
GAS LISTING init.s 			page 20


 277 03d0 83EC04   	>  subl $4,%esp
 277              	>  .endif
 277 03d3 0FA8     	>  push %gs
 277 03d5 0FA0     	>  push %fs
 277 03d7 06       	>  push %es
 277 03d8 1E       	>  push %ds
 277 03d9 60       	>  pusha 
 277 03da 54       	>  push %esp
 277 03db B8000000 	>  movl $0,%eax
 277      00
 277 03e0 E84A0200 	>  call nohandler
 277      00
 277 03e5 83C404   	>  addl $4,%esp
 277 03e8 07       	>  popl %es
 277 03e9 1F       	>  popl %ds
 277 03ea 61       	>  popa
 277 03eb 83C404   	>  addl $4,%esp
 277 03ee CF       	>  iret
 278              		handler	num=1,  func=nohandler			# debug
 278 03ef 90       	>  .align 16
 278              	> exc1:
 278              	>  .if 0==0
 278 03f0 83EC04   	>  subl $4,%esp
 278              	>  .endif
 278 03f3 0FA8     	>  push %gs
 278 03f5 0FA0     	>  push %fs
 278 03f7 06       	>  push %es
 278 03f8 1E       	>  push %ds
 278 03f9 60       	>  pusha 
 278 03fa 54       	>  push %esp
 278 03fb B8010000 	>  movl $1,%eax
 278      00
 278 0400 E82A0200 	>  call nohandler
 278      00
 278 0405 83C404   	>  addl $4,%esp
 278 0408 07       	>  popl %es
 278 0409 1F       	>  popl %ds
 278 040a 61       	>  popa
 278 040b 83C404   	>  addl $4,%esp
 278 040e CF       	>  iret
 279              		handler	num=2,  func=nohandler			# NMI
 279 040f 90       	>  .align 16
 279              	> exc2:
 279              	>  .if 0==0
 279 0410 83EC04   	>  subl $4,%esp
 279              	>  .endif
 279 0413 0FA8     	>  push %gs
 279 0415 0FA0     	>  push %fs
 279 0417 06       	>  push %es
 279 0418 1E       	>  push %ds
 279 0419 60       	>  pusha 
 279 041a 54       	>  push %esp
 279 041b B8020000 	>  movl $2,%eax
 279      00
 279 0420 E80A0200 	>  call nohandler
 279      00
 279 0425 83C404   	>  addl $4,%esp
GAS LISTING init.s 			page 21


 279 0428 07       	>  popl %es
 279 0429 1F       	>  popl %ds
 279 042a 61       	>  popa
 279 042b 83C404   	>  addl $4,%esp
 279 042e CF       	>  iret
 280              		handler	num=3,  func=nohandler			# breakpoint
 280 042f 90       	>  .align 16
 280              	> exc3:
 280              	>  .if 0==0
 280 0430 83EC04   	>  subl $4,%esp
 280              	>  .endif
 280 0433 0FA8     	>  push %gs
 280 0435 0FA0     	>  push %fs
 280 0437 06       	>  push %es
 280 0438 1E       	>  push %ds
 280 0439 60       	>  pusha 
 280 043a 54       	>  push %esp
 280 043b B8030000 	>  movl $3,%eax
 280      00
 280 0440 E8EA0100 	>  call nohandler
 280      00
 280 0445 83C404   	>  addl $4,%esp
 280 0448 07       	>  popl %es
 280 0449 1F       	>  popl %ds
 280 044a 61       	>  popa
 280 044b 83C404   	>  addl $4,%esp
 280 044e CF       	>  iret
 281              		handler	num=4,  func=nohandler			# overflow
 281 044f 90       	>  .align 16
 281              	> exc4:
 281              	>  .if 0==0
 281 0450 83EC04   	>  subl $4,%esp
 281              	>  .endif
 281 0453 0FA8     	>  push %gs
 281 0455 0FA0     	>  push %fs
 281 0457 06       	>  push %es
 281 0458 1E       	>  push %ds
 281 0459 60       	>  pusha 
 281 045a 54       	>  push %esp
 281 045b B8040000 	>  movl $4,%eax
 281      00
 281 0460 E8CA0100 	>  call nohandler
 281      00
 281 0465 83C404   	>  addl $4,%esp
 281 0468 07       	>  popl %es
 281 0469 1F       	>  popl %ds
 281 046a 61       	>  popa
 281 046b 83C404   	>  addl $4,%esp
 281 046e CF       	>  iret
 282              		handler	num=5,  func=nohandler			# bound
 282 046f 90       	>  .align 16
 282              	> exc5:
 282              	>  .if 0==0
 282 0470 83EC04   	>  subl $4,%esp
 282              	>  .endif
 282 0473 0FA8     	>  push %gs
 282 0475 0FA0     	>  push %fs
GAS LISTING init.s 			page 22


 282 0477 06       	>  push %es
 282 0478 1E       	>  push %ds
 282 0479 60       	>  pusha 
 282 047a 54       	>  push %esp
 282 047b B8050000 	>  movl $5,%eax
 282      00
 282 0480 E8AA0100 	>  call nohandler
 282      00
 282 0485 83C404   	>  addl $4,%esp
 282 0488 07       	>  popl %es
 282 0489 1F       	>  popl %ds
 282 048a 61       	>  popa
 282 048b 83C404   	>  addl $4,%esp
 282 048e CF       	>  iret
 283              		handler	num=6,  func=nohandler			# undefined opcode
 283 048f 90       	>  .align 16
 283              	> exc6:
 283              	>  .if 0==0
 283 0490 83EC04   	>  subl $4,%esp
 283              	>  .endif
 283 0493 0FA8     	>  push %gs
 283 0495 0FA0     	>  push %fs
 283 0497 06       	>  push %es
 283 0498 1E       	>  push %ds
 283 0499 60       	>  pusha 
 283 049a 54       	>  push %esp
 283 049b B8060000 	>  movl $6,%eax
 283      00
 283 04a0 E88A0100 	>  call nohandler
 283      00
 283 04a5 83C404   	>  addl $4,%esp
 283 04a8 07       	>  popl %es
 283 04a9 1F       	>  popl %ds
 283 04aa 61       	>  popa
 283 04ab 83C404   	>  addl $4,%esp
 283 04ae CF       	>  iret
 284              		handler	num=7,  func=nohandler			# nomath
 284 04af 90       	>  .align 16
 284              	> exc7:
 284              	>  .if 0==0
 284 04b0 83EC04   	>  subl $4,%esp
 284              	>  .endif
 284 04b3 0FA8     	>  push %gs
 284 04b5 0FA0     	>  push %fs
 284 04b7 06       	>  push %es
 284 04b8 1E       	>  push %ds
 284 04b9 60       	>  pusha 
 284 04ba 54       	>  push %esp
 284 04bb B8070000 	>  movl $7,%eax
 284      00
 284 04c0 E86A0100 	>  call nohandler
 284      00
 284 04c5 83C404   	>  addl $4,%esp
 284 04c8 07       	>  popl %es
 284 04c9 1F       	>  popl %ds
 284 04ca 61       	>  popa
 284 04cb 83C404   	>  addl $4,%esp
GAS LISTING init.s 			page 23


 284 04ce CF       	>  iret
 285              		handler	num=8,  func=nohandler, errorcode=1	# doublefault
 285 04cf 90       	>  .align 16
 285              	> exc8:
 285              	>  .if 1==0
 285              	>  subl $4,%esp
 285              	>  .endif
 285 04d0 0FA8     	>  push %gs
 285 04d2 0FA0     	>  push %fs
 285 04d4 06       	>  push %es
 285 04d5 1E       	>  push %ds
 285 04d6 60       	>  pusha 
 285 04d7 54       	>  push %esp
 285 04d8 B8080000 	>  movl $8,%eax
 285      00
 285 04dd E84D0100 	>  call nohandler
 285      00
 285 04e2 83C404   	>  addl $4,%esp
 285 04e5 07       	>  popl %es
 285 04e6 1F       	>  popl %ds
 285 04e7 61       	>  popa
 285 04e8 83C404   	>  addl $4,%esp
 285 04eb CF       	>  iret
 286              		handler num=9,  func=nohandler			# coproc seg overrun
 286 04ec 8D742600 	>  .align 16
 286              	> exc9:
 286              	>  .if 0==0
 286 04f0 83EC04   	>  subl $4,%esp
 286              	>  .endif
 286 04f3 0FA8     	>  push %gs
 286 04f5 0FA0     	>  push %fs
 286 04f7 06       	>  push %es
 286 04f8 1E       	>  push %ds
 286 04f9 60       	>  pusha 
 286 04fa 54       	>  push %esp
 286 04fb B8090000 	>  movl $9,%eax
 286      00
 286 0500 E82A0100 	>  call nohandler
 286      00
 286 0505 83C404   	>  addl $4,%esp
 286 0508 07       	>  popl %es
 286 0509 1F       	>  popl %ds
 286 050a 61       	>  popa
 286 050b 83C404   	>  addl $4,%esp
 286 050e CF       	>  iret
 287              		handler num=10, func=nohandler, errorcode=1	# invalid tss
 287 050f 90       	>  .align 16
 287              	> exc10:
 287              	>  .if 1==0
 287              	>  subl $4,%esp
 287              	>  .endif
 287 0510 0FA8     	>  push %gs
 287 0512 0FA0     	>  push %fs
 287 0514 06       	>  push %es
 287 0515 1E       	>  push %ds
 287 0516 60       	>  pusha 
 287 0517 54       	>  push %esp
GAS LISTING init.s 			page 24


 287 0518 B80A0000 	>  movl $10,%eax
 287      00
 287 051d E80D0100 	>  call nohandler
 287      00
 287 0522 83C404   	>  addl $4,%esp
 287 0525 07       	>  popl %es
 287 0526 1F       	>  popl %ds
 287 0527 61       	>  popa
 287 0528 83C404   	>  addl $4,%esp
 287 052b CF       	>  iret
 288              		handler num=11, func=nohandler, errorcode=1	# segment not present
 288 052c 8D742600 	>  .align 16
 288              	> exc11:
 288              	>  .if 1==0
 288              	>  subl $4,%esp
 288              	>  .endif
 288 0530 0FA8     	>  push %gs
 288 0532 0FA0     	>  push %fs
 288 0534 06       	>  push %es
 288 0535 1E       	>  push %ds
 288 0536 60       	>  pusha 
 288 0537 54       	>  push %esp
 288 0538 B80B0000 	>  movl $11,%eax
 288      00
 288 053d E8ED0000 	>  call nohandler
 288      00
 288 0542 83C404   	>  addl $4,%esp
 288 0545 07       	>  popl %es
 288 0546 1F       	>  popl %ds
 288 0547 61       	>  popa
 288 0548 83C404   	>  addl $4,%esp
 288 054b CF       	>  iret
 289              		handler num=12, func=nohandler, errorcode=1	# stack-segment fault
 289 054c 8D742600 	>  .align 16
 289              	> exc12:
 289              	>  .if 1==0
 289              	>  subl $4,%esp
 289              	>  .endif
 289 0550 0FA8     	>  push %gs
 289 0552 0FA0     	>  push %fs
 289 0554 06       	>  push %es
 289 0555 1E       	>  push %ds
 289 0556 60       	>  pusha 
 289 0557 54       	>  push %esp
 289 0558 B80C0000 	>  movl $12,%eax
 289      00
 289 055d E8CD0000 	>  call nohandler
 289      00
 289 0562 83C404   	>  addl $4,%esp
 289 0565 07       	>  popl %es
 289 0566 1F       	>  popl %ds
 289 0567 61       	>  popa
 289 0568 83C404   	>  addl $4,%esp
 289 056b CF       	>  iret
 290              		handler num=13, func=nohandler, errorcode=1	# general protection
 290 056c 8D742600 	>  .align 16
 290              	> exc13:
GAS LISTING init.s 			page 25


 290              	>  .if 1==0
 290              	>  subl $4,%esp
 290              	>  .endif
 290 0570 0FA8     	>  push %gs
 290 0572 0FA0     	>  push %fs
 290 0574 06       	>  push %es
 290 0575 1E       	>  push %ds
 290 0576 60       	>  pusha 
 290 0577 54       	>  push %esp
 290 0578 B80D0000 	>  movl $13,%eax
 290      00
 290 057d E8AD0000 	>  call nohandler
 290      00
 290 0582 83C404   	>  addl $4,%esp
 290 0585 07       	>  popl %es
 290 0586 1F       	>  popl %ds
 290 0587 61       	>  popa
 290 0588 83C404   	>  addl $4,%esp
 290 058b CF       	>  iret
 291              		handler num=14, func=nohandler, errorcode=1	# page fault
 291 058c 8D742600 	>  .align 16
 291              	> exc14:
 291              	>  .if 1==0
 291              	>  subl $4,%esp
 291              	>  .endif
 291 0590 0FA8     	>  push %gs
 291 0592 0FA0     	>  push %fs
 291 0594 06       	>  push %es
 291 0595 1E       	>  push %ds
 291 0596 60       	>  pusha 
 291 0597 54       	>  push %esp
 291 0598 B80E0000 	>  movl $14,%eax
 291      00
 291 059d E88D0000 	>  call nohandler
 291      00
 291 05a2 83C404   	>  addl $4,%esp
 291 05a5 07       	>  popl %es
 291 05a6 1F       	>  popl %ds
 291 05a7 61       	>  popa
 291 05a8 83C404   	>  addl $4,%esp
 291 05ab CF       	>  iret
 292              		handler num=16, func=nohandler			# math fault
 292 05ac 8D742600 	>  .align 16
 292              	> exc16:
 292              	>  .if 0==0
 292 05b0 83EC04   	>  subl $4,%esp
 292              	>  .endif
 292 05b3 0FA8     	>  push %gs
 292 05b5 0FA0     	>  push %fs
 292 05b7 06       	>  push %es
 292 05b8 1E       	>  push %ds
 292 05b9 60       	>  pusha 
 292 05ba 54       	>  push %esp
 292 05bb B8100000 	>  movl $16,%eax
 292      00
 292 05c0 E86A0000 	>  call nohandler
 292      00
GAS LISTING init.s 			page 26


 292 05c5 83C404   	>  addl $4,%esp
 292 05c8 07       	>  popl %es
 292 05c9 1F       	>  popl %ds
 292 05ca 61       	>  popa
 292 05cb 83C404   	>  addl $4,%esp
 292 05ce CF       	>  iret
 293              		handler num=17, func=nohandler, errorcode=1	# alignment check
 293 05cf 90       	>  .align 16
 293              	> exc17:
 293              	>  .if 1==0
 293              	>  subl $4,%esp
 293              	>  .endif
 293 05d0 0FA8     	>  push %gs
 293 05d2 0FA0     	>  push %fs
 293 05d4 06       	>  push %es
 293 05d5 1E       	>  push %ds
 293 05d6 60       	>  pusha 
 293 05d7 54       	>  push %esp
 293 05d8 B8110000 	>  movl $17,%eax
 293      00
 293 05dd E84D0000 	>  call nohandler
 293      00
 293 05e2 83C404   	>  addl $4,%esp
 293 05e5 07       	>  popl %es
 293 05e6 1F       	>  popl %ds
 293 05e7 61       	>  popa
 293 05e8 83C404   	>  addl $4,%esp
 293 05eb CF       	>  iret
 294              		handler num=18, func=nohandler			# machine check
 294 05ec 8D742600 	>  .align 16
 294              	> exc18:
 294              	>  .if 0==0
 294 05f0 83EC04   	>  subl $4,%esp
 294              	>  .endif
 294 05f3 0FA8     	>  push %gs
 294 05f5 0FA0     	>  push %fs
 294 05f7 06       	>  push %es
 294 05f8 1E       	>  push %ds
 294 05f9 60       	>  pusha 
 294 05fa 54       	>  push %esp
 294 05fb B8120000 	>  movl $18,%eax
 294      00
 294 0600 E82A0000 	>  call nohandler
 294      00
 294 0605 83C404   	>  addl $4,%esp
 294 0608 07       	>  popl %es
 294 0609 1F       	>  popl %ds
 294 060a 61       	>  popa
 294 060b 83C404   	>  addl $4,%esp
 294 060e CF       	>  iret
 295              		handler num=19, func=nohandler			# SIMD fp exception
 295 060f 90       	>  .align 16
 295              	> exc19:
 295              	>  .if 0==0
 295 0610 83EC04   	>  subl $4,%esp
 295              	>  .endif
 295 0613 0FA8     	>  push %gs
GAS LISTING init.s 			page 27


 295 0615 0FA0     	>  push %fs
 295 0617 06       	>  push %es
 295 0618 1E       	>  push %ds
 295 0619 60       	>  pusha 
 295 061a 54       	>  push %esp
 295 061b B8130000 	>  movl $19,%eax
 295      00
 295 0620 E80A0000 	>  call nohandler
 295      00
 295 0625 83C404   	>  addl $4,%esp
 295 0628 07       	>  popl %es
 295 0629 1F       	>  popl %ds
 295 062a 61       	>  popa
 295 062b 83C404   	>  addl $4,%esp
 295 062e CF       	>  iret
 296              	
 297              	nohandler:			# dummy interrupt handler
 298 062f 8B5C2404 		movl	4(%esp), %ebx	# get frame pointer
 299 0633 53       		pushl	%ebx
 300 0634 50       		pushl	%eax
 301 0635 68460600 		pushl	$excepted
 301      00
 302 063a E8FCFFFF 		call	printf
 302      FF
 303 063f 83C40C   		addl	$12, %esp
 304              	
 305 0642 F4       	1:	hlt
 306 0643 EBFD     		jmp 1b
 307              	
 308 0645 C3       		ret
 309              	excepted:
 310 0646 45786365 		.asciz	"Exception 0x%x, frame=0x%x\n"
 310      7074696F 
 310      6E203078 
 310      25782C20 
 310      6672616D 
 311              	
 312              	#--------------------------------------------------------------------------
 313              	# Simple system call handler:
 314              	#--------------------------------------------------------------------------
 315              	
 316              		.text
 317 0662 83EC04   	syscall:subl	$4, %esp	# Fake an error code
 318 0665 0FA8     		push	%gs		# Save segments
 319 0667 0FA0     		push	%fs
 320 0669 06       		push	%es
 321 066a 1E       		push	%ds
 322 066b 60       		pusha			# Save registers
 323 066c 8D250010 		leal	stack, %esp	# Switch to kernel stack
 323      0000
 324 0672 E9FCFFFF 		jmp	csyscall
 324      FF
 325              	
 326              	#--------------------------------------------------------------------------
 327              	# Switch to user mode:  Takes a single parameter, which provides the
 328              	# initial context for the user process.
 329              	#
GAS LISTING init.s 			page 28


 330              	# Size of context is 4 * (8 + 4 + 6) = 4*18 = 72
 331              	# - 8 general registers: edi, esi, ebp, esp, ebx, edx, ecx, eax
 332              	# - 4 segment registers: ds, es, fs, gs
 333              	# - 6 interrupt frame words: errorcode, eip, cs, eflags, esp, ss
 334              	#--------------------------------------------------------------------------
 335              	
 336              		.set	CONTEXT_SIZE, 72
 337              		.globl	switchToUser
 338              	switchToUser:
 339 0677 8B442404 		movl	4(%esp), %eax	# Load address of the user context
 340 067b 89C4     		movl	%eax, %esp	# Reset stack to base of user context
 341 067d 83C048   		addl	$CONTEXT_SIZE, %eax
 342 0680 A3041000 		movl	%eax, esp0	# Set stack address for kernel reentry
 342      00
 343 0685 61       		popa			# Restore registers
 344 0686 1F       		pop	%ds		# Restore segments
 345 0687 07       		pop	%es
 346 0688 0FA1     		pop	%fs
 347 068a 0FA9     		pop	%gs
 348 068c 83C404   		addl	$4, %esp	# Skip error code
 349 068f CF       		iret			# Return from interrupt
 350              	
 351              	#-- Done ---------------------------------------------------------------------
GAS LISTING init.s 			page 29


DEFINED SYMBOLS
              init.s:10     *ABS*:0000000000000000 RESERVED
              init.s:18     .data:0000000000001000 stack
              init.s:26     .text:0000000000000000 entry
              init.s:165    .text:0000000000000019 initGDT
              init.s:232    .text:000000000000016e initIDT
              init.s:45     .data:0000000000001000 tss
              init.s:46     .data:0000000000001004 esp0
                            *ABS*:0000000000000028 KERN_DS
              init.s:70     *ABS*:0000000000000068 tss_len
              init.s:93     *ABS*:0000000000000008 GDT_ENTRIES
              init.s:94     *ABS*:0000000000000040 GDT_SIZE
              init.s:99     .data:0000000000001080 gdt
              init.s:102    .data:00000000000010c0 gdtptr
              init.s:105    *ABS*:0000000000000013 GDT_DATA
              init.s:106    *ABS*:000000000000001b GDT_CODE
              init.s:107    *ABS*:0000000000000009 GDT_TSS32
              init.s:166    *ABS*:0000000000000020 KERN_CS
              init.s:172    *ABS*:0000000000000033 USER_CS
              init.s:175    *ABS*:000000000000003b USER_DS
              init.s:178    *ABS*:0000000000000018 TSS
              init.s:197    *ABS*:0000000000000100 IDT_ENTRIES
              init.s:198    *ABS*:0000000000000800 IDT_SIZE
              init.s:199    *ABS*:0000000000000000 IDT_INTR
              init.s:200    *ABS*:0000000000000100 IDT_TRAP
              init.s:204    .data:00000000000010c8 idtptr
              init.s:207    .data:00000000000010d0 idt
              init.s:277    .text:00000000000003d0 exc0
              init.s:278    .text:00000000000003f0 exc1
              init.s:279    .text:0000000000000410 exc2
              init.s:280    .text:0000000000000430 exc3
              init.s:281    .text:0000000000000450 exc4
              init.s:282    .text:0000000000000470 exc5
              init.s:283    .text:0000000000000490 exc6
              init.s:284    .text:00000000000004b0 exc7
              init.s:285    .text:00000000000004d0 exc8
              init.s:286    .text:00000000000004f0 exc9
              init.s:287    .text:0000000000000510 exc10
              init.s:288    .text:0000000000000530 exc11
              init.s:289    .text:0000000000000550 exc12
              init.s:290    .text:0000000000000570 exc13
              init.s:291    .text:0000000000000590 exc14
              init.s:292    .text:00000000000005b0 exc16
              init.s:293    .text:00000000000005d0 exc17
              init.s:294    .text:00000000000005f0 exc18
              init.s:295    .text:0000000000000610 exc19
              init.s:317    .text:0000000000000662 syscall
              init.s:297    .text:000000000000062f nohandler
              init.s:309    .text:0000000000000646 excepted
              init.s:336    *ABS*:0000000000000048 CONTEXT_SIZE
              init.s:338    .text:0000000000000677 switchToUser

UNDEFINED SYMBOLS
kernel
printf
csyscall
